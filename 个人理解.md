#### 响应式原理
1. 在vue实例化时会将实例中传入的 `options` 中的 `data` 进行 `defindeProperty` 的操作，为属性添加 `get` 和 `set` 方法
2. 在这个操作中，会对递归的对**每一个data属性**，创建一个dep实例， dep用来进行依赖收集和属性标识。
3. 之后用 `compiler` 模板解析，通过**正则识别和拆解模板的**方式生成了对应的**ast树**，ast树是对html文档的解析，争对的是**语法层面**。
4. 解析为语法树之后，根据ast转换为 由 `_c, _v, _s`组成的字符串 ` _c('div',{id:"app",style:{"color":"red"}},_v("222"))`这种格式的内容。再通过 `with` 和 `new Function()`包裹 **生成render函数**，render函数返回可以执行的那堆字符串构成的函数
5. **执行render函数**，返回相应的 **VNode** 结构： `{vm, tag, key, data, children,text}`。
6. 最后通过 `_updata()` 中的 `patch`方法，将旧节点移除，并根据 vnode 生成真实dom挂载上去
7. 但是**在render函数执行前**， **先new了一个 Watcher类，并把渲染挂载方法保存好**，开始进行依赖的收集
8. new Watcher的时候会将 Dep.targe 指向这个 新watch实例（在get属性的时候判断是否被需要，进行后续操作，render和 update），
9. 之后进行 render 函数的执行，render函数执行过程中就会访问 data中的属性。这时判断是否有 `Dep.targe`，如果有就会进行依赖收集，
10. 依赖收集 ： 首先判断成功有 Dep.targe 后，会让**这个属性的 Dep实例**  调用`depend()`方法,这个方法又会执行 `Dep.target.addDep(this)` 先让 watcher实例添加这个 Dep 实例，这里会进行一个去重操作，再返回给dep实例添加Watcher。
11. watcher 和 dep 绑定完成后。 如果数据发生变化就会调用 set中的 `dep.notify()` 让用到这个属性的所有 watcher 重新进行 虚拟节点更新挂载


